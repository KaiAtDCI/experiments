<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Joel Peltonen">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }

    #controls {
      display: flex;
      flex-direction: column;
      justify-self: center;
      text-align: right;
      background-color: whitesmoke;
    }

    .input-group {
      display: flex;
      align-items: center;
      margin: .5em;
    }

    label {
      width: 10em;
      margin-right: .5em;
    }

    #graphics {
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body onload="initPage()">
<div id="controls">
  <div class="input-group">
    <label for="imageFile">Image File:</label>
    <input type="file" name="" id="imageFile">
  </div>
  <div class="input-group">
    <label for="multiplierInput">Pixelation Factor:</label>
    <input type="number" id="multiplierInput" min="0" max="666" value="2" />
  </div>
</div>
<div id="graphics">
  <img id="sourceImage" src="" alt="source image"/>
  <canvas id="targetCanvas"></canvas>
</div>
Joel Peltonen 2021

<script type="text/javascript">

  const initialFilename = 'Pink-Gonzo.jpg';
  const maxFileSize = 900000;
  const maxPixelationFactor = 666;
  const minPixelationFactor = 2;
  const initialPixelationFactor = 5;
  let pixelationFactor = initialPixelationFactor;

  // Are you KIDDING me with this type casting?
  const canvas = /** @type {HTMLCanvasElement} */ document.querySelector('#targetCanvas');
  const ctx = /** @type {CanvasRenderingContext2d} */ canvas.getContext('2d');
  const fileDialog = document.querySelector("#imageFile");
  const sourceImage = document.querySelector('#sourceImage');
  const multiplierInput = document.querySelector("#multiplierInput");

  // init page (triggered by body onload event)
  function initPage() {
    sourceImage.setAttribute('src', initialFilename);
    multiplierInput.setAttribute('value', pixelationFactor);
  }

  // event handlers
  fileDialog.addEventListener('change', () => {
    readFile();
    draw();
  })

  multiplierInput.addEventListener('change', () => {
    pixelationFactor = parseInt(multiplierInput.value);
    if (pixelationFactor > maxPixelationFactor) {
      multiplierInput.value = maxPixelationFactor;
      return alert(`Pixelation factor exceeds maximum of ${maxPixelationFactor}!`);
    } else if (pixelationFactor < minPixelationFactor) {
      multiplierInput.value = minPixelationFactor;
      return alert(`Pixelation factor falls below minimum of ${minPixelationFactor}!`);
    }
    draw();
  })

  sourceImage.addEventListener('load', () => {
    draw(); // triggered when sourceImage was loaded
  });

  function draw() {
    let imageHeight = sourceImage.height;
    let imageWidth = sourceImage.width;
    canvas.width = imageWidth;
    canvas.height = imageHeight;

    // draw centered source image
    const posX = Math.ceil(canvas.width/2 - imageWidth/2);
    const posY = Math.ceil(canvas.height/2 - imageHeight/2);
    ctx.drawImage(sourceImage, posX, posY, imageWidth, imageHeight);

    // read rendered image pixels
    const imageData = ctx.getImageData(posX, posY, imageWidth, imageHeight);
    const pixelvalues = imageData.data;
    // console.log(pixelvalues)

    // draw pixelized image
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // lööp over image, each 5th pixel
    let loopkiller = 100000; // around 100k

    for (let row = 1; row < imageHeight; row = row + pixelationFactor) {
      for (let col = 1; col < imageWidth; col = col + pixelationFactor) {
        loopkiller--;
        if (loopkiller < 0) { return console.log("killed"); }

        // get 1st pixel color
        const pixelReference = ((row*imageWidth)+(col))*4;
        if (pixelReference === null || typeof pixelReference === "undefined") {return console.log("Invalid pixel reference"); }

        const color = `rgb(
              ${pixelvalues[pixelReference]},
              ${pixelvalues[pixelReference+1]},
              ${pixelvalues[pixelReference+2]}
            )`;
        // +3 would be the alpha channel, which is pointless for us
        // console.log(pixelReference, color);
        // draw "pixel" ball
        ctx.fillStyle = color;
        ctx.fillRect(posX + col, posY + row, pixelationFactor, pixelationFactor);
      }
    }
  }

  function readFile() {
    const file = fileDialog.files[0];
    // console.log({ file });
    if (file.size > maxFileSize) {
      return alert(`File size exceeds ${maxFileSize} bytes!`);
    }
    const fr = new FileReader();
    fr.onload = () => {
      sourceImage.src = fr.result;      // onload fires after reading is complete
    };
    fr.readAsDataURL(file);             // begin reading
  }
</script>
</body>
</html>